"0","make_cohort_roi_table_fraction_overlap <- function(mark, rois, blacklist_regions_gr = blacklist_encode) {"
"0","  # Establish tiled regions of interest GRanges"
"0","  # Remove blacklisted areas"
"0","  rois_filtered <- "
"0","    rois %>% "
"0","    keepSeqlevels(const_canonical_chromosomes, pruning.mode = ""coarse"") %>%"
"0","    filter_by_non_overlaps(blacklist_regions_gr)"
"0","  "
"0","  # Tile promoter ranges into 150bp tiles"
"0","  rois_filtered_tiled <-"
"0","    rois_filtered %>% "
"0","    # tile_ranges(width = 150) %>% # Do not tile promoters into even smaller sections. Each tile corresponds to 1 promoter"
"0","    plyranges::mutate(tile_id = seq_along(.))"
"0","  "
"0","  # Create table containing peak overlap fraction in tiles for entire cohort"
"0","  for (current_sample in names(list_peak[[mark]])) {"
"0","    # Read in bigWig corresponding to current sample being worked on"
"0","    current_peaks <- list_peak[[mark]][[current_sample]] %>% keepSeqlevels(const_canonical_chromosomes, pruning.mode = ""coarse"")"
"0","    "
"0","    # Do a raw overlap keeping all metadata"
"0","    raw_overlap <- join_overlap_intersect(rois_filtered_tiled, current_peaks)"
"0","    "
"0","    # Create a tibble with tile_id as key and peak intersection width as value"
"0","    # For the tile_ids intersecting multiple separate peaks, group by tile_id and sum total tile_id width covered"
"0","    raw_overlap_widths <- "
"0","      tibble(tile_id                   = raw_overlap$tile_id,"
"0","             peak_intersection_width   = raw_overlap %>% width()) %>% "
"0","      group_by(tile_id) %>% "
"0","      summarize(peak_intersection_width_total = sum(peak_intersection_width))"
"0","    "
"0","    # Left join peak intersection widths on tile_id of original tiles"
"0","    current_peaks_fraction_overlap_column <-"
"0","      rois_filtered_tiled %>% "
"0","      as_tibble() %>% "
"0","      left_join(raw_overlap_widths, by = ""tile_id"") %>% "
"0","      mutate(peak_intersection_width_total = replace_na(peak_intersection_width_total, 0)) %>% # Replace no-hit tiles with 0 overlap width"
"0","      mutate(fraction_overlap = peak_intersection_width_total/width) %>% "
"0","      pull(fraction_overlap)"
"0","    "
"0","    # Add mean pileup depth per tile for current sample to rois_filtered_tiled as a new column"
"0","    rois_filtered_tiled <- "
"0","      rois_filtered_tiled %>% "
"0","      plyranges::mutate(""{current_sample}"" := current_peaks_fraction_overlap_column)"
"0","    }"
"0","  # Return completed table"
"0","  rois_filtered_tiled"
"0","}"
